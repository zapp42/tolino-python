# Osiander.de Login Process
GET https://auth.osiander.de/login
<- PHPSESSID: This cookie is needed in the upcoming POST request to /authenticate

POST https://auth.osiander.de/authenticate
-> Cookie: PHPSESSID
-> username, password, redirect_uri
<- 302 redirect to redirect_uri with ?code=xxx, which is the oauth code to get the token in the next step

GET https://bosh.pageplace.de/bosh/rest/v2/resellerconfig
-> Header: reseller_id=23
<- JSON with all osiander specific URLs which are otherwise hardcoded in the partner_settings. Maybe use this to dynamically get those settings?

POST https://auth.osiander.de/token
-> Data: client_id, grant_type, code (from redirect location above), scope, redirect_uri
<- JSON: access_token, expires_in, token_type, scope, refresh_token


# tolino-python login sequence
If login_form_url is set in partner_settings:
  GET login_form_url
    -> Needs client_id, scope, reader_url, x_buchde.skin_id, x_buchde.mandant_id in settings
    -> This is only done to save all returned sessions cookies for future requests (for osiander this is the PHPSESSID cookie)

POST to login_url
-> username, password, extra from login_form settings
This call is expected to return an login_cookie (as defined in settings) and will fail if none is returned. For osiander there is no such cookie but we can probably get away with the PHPSESSID cookie.

If tat_url is defined in the settings:
  GET tat_url
  -> Whatever that is, but is seems to be another method to acquire an access_token
Else:
  GET auth_url
  -> This call is expected to redirect with a ?code parameter, which is extracted from the response 'Location' header and stored in auth_code
  -> This breaks the osiander.de login seq. as the redirect already occured in the POST login_url step above

POST token_url
-> Data: client_id, code (auth_code from redirection), scope, redirect_uri (reader_url from settings)
<- JSON: access_token, refresh_token, token_expires
